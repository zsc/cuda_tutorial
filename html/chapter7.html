<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第7章：原子操作与同步原语</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">CUDA 高性能编程实战教程</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第1章：CUDA硬件架构深度剖析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第2章：CUDA编程模型与执行模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第3章：全局内存优化策略</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第4章：共享内存与Bank Conflict</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第5章：寄存器优化与常量内存</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第6章：Warp级编程与协作组</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第7章：原子操作与同步原语</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第8章：PTX内联与底层优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第9章：张量核心与混合精度计算</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第10章：CUTLASS深度解析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第11章：激光雷达点云处理加速</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第12章：多传感器融合的并行化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第13章：实时语义分割与实例分割</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第14章：路径规划与轨迹优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第15章：视觉SLAM的GPU加速</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第16章：机械臂运动规划</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter17.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第17章：强化学习推理加速</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter18.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第18章：大规模点云重建与网格化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter19.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第19章：多GPU编程与扩展</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter20.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第20章：CUDA Graph与内核融合</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter21.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第21章：嵌入式GPU开发（Jetson）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter22.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第22章：稀疏计算与动态稀疏</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter23.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第23章：量化与低精度计算</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter24.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第24章：新一代GPU特性展望</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter25.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第25章：性能分析与调优方法论</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter26.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第26章：CUDA调试技术与错误处理</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter27.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第27章：开发环境与工具链配置</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="7">第7章：原子操作与同步原语</h1>
<p>本章深入探讨CUDA中的原子操作和同步机制。我们将从硬件层面理解原子操作的实现原理，掌握各种同步原语的使用场景，并通过实现高并发哈希表来综合运用这些技术。对于自动驾驶和具身智能应用中的并发数据结构设计，这些知识至关重要。</p>
<h2 id="71">7.1 原子操作的硬件实现</h2>
<h3 id="711">7.1.1 原子操作的本质</h3>
<p>原子操作保证了在多线程环境下对共享内存位置的读-改-写操作的原子性。在GPU上，当多个线程同时访问同一内存地址时，原子操作确保每个操作都完整执行，不会被其他线程打断。</p>
<p>硬件层面，原子操作通过以下机制实现：</p>
<ol>
<li>
<p><strong>L2缓存原子单元</strong>：从Fermi架构开始，NVIDIA GPU在L2缓存中集成了专门的原子操作单元。这些单元能够直接在缓存行上执行原子操作，避免了数据在内存层次结构中的移动。</p>
</li>
<li>
<p><strong>内存控制器原子单元</strong>：对于全局内存的原子操作，内存控制器包含专门的原子操作逻辑，可以在DRAM接口处直接执行原子操作。</p>
</li>
<li>
<p><strong>共享内存原子操作</strong>：在SM内部，共享内存的原子操作通过bank锁定机制实现。当一个warp中的线程对同一bank执行原子操作时，硬件会串行化这些访问。</p>
</li>
</ol>
<h3 id="712">7.1.2 原子操作的性能特征</h3>
<p>原子操作的延迟特征：</p>
<div class="codehilite"><pre><span></span><code>操作类型         延迟(cycles)   吞吐量
----------------------------------------
全局内存原子      200-600       低(串行化)
共享内存原子      20-40         中等
L2缓存原子       100-200       中等
寄存器原子       不支持         -
</code></pre></div>

<p>关键性能因素：</p>
<ol>
<li><strong>地址冲突</strong>：多个线程访问同一地址会导致串行化</li>
<li><strong>内存位置</strong>：L2缓存中的原子操作比全局内存快3-5倍</li>
<li><strong>操作类型</strong>：简单操作(add)比复杂操作(CAS)快</li>
<li><strong>访问模式</strong>：分散的访问模式优于集中访问</li>
</ol>
<h3 id="713">7.1.3 原子操作的内存序</h3>
<p>CUDA支持多种内存序模型：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 默认原子操作 - 宽松内存序</span>
<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// 使用内存序参数 (CUDA 11.0+)</span>
<span class="n">atomicAdd_system</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// 系统范围一致性</span>
<span class="n">atomicAdd_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">   </span><span class="c1">// 块范围一致性</span>
</code></pre></div>

<p>内存序层次：</p>
<div class="codehilite"><pre><span></span><code>       系统范围 (system)
           ↑
       设备范围 (device)  
           ↑
        块范围 (block)
           ↑
       warp范围 (默认)
</code></pre></div>

<h3 id="714">7.1.4 原子操作优化策略</h3>
<ol>
<li><strong>批量化原子操作</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 低效：每个线程执行原子操作</span>
<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_counter</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// 高效：先在warp内归约</span>
<span class="kt">int</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__activemask</span><span class="p">();</span>
<span class="kt">int</span><span class="w"> </span><span class="n">leader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__ffs</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">warp_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__popc</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lane_id</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">leader</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_counter</span><span class="p">,</span><span class="w"> </span><span class="n">warp_sum</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<ol start="2">
<li><strong>使用warp聚合函数</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// CUDA 11.0+ 提供的warp级原子聚合</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/reduce.h&gt;</span>
<span class="n">namespace</span><span class="w"> </span><span class="n">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">());</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tile</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">,</span><span class="w"> </span><span class="n">tile</span><span class="p">.</span><span class="n">ballot</span><span class="p">(</span><span class="n">predicate</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<ol start="3">
<li><strong>原子操作合并</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 使用atomicCAS实现复杂原子操作</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">atomicMax</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">addr_as_uint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">addr_as_uint</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">assumed</span><span class="p">;</span>

<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">assumed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">old_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__uint_as_float</span><span class="p">(</span><span class="n">assumed</span><span class="p">);</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">new_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fmaxf</span><span class="p">(</span><span class="n">old_value</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="w">        </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicCAS</span><span class="p">(</span><span class="n">addr_as_uint</span><span class="p">,</span><span class="w"> </span><span class="n">assumed</span><span class="p">,</span><span class="w"> </span>
<span class="w">                       </span><span class="n">__float_as_uint</span><span class="p">(</span><span class="n">new_value</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">assumed</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">old</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__uint_as_float</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="72">7.2 自定义原子操作</h2>
<h3 id="721-cas">7.2.1 基于CAS的自定义原子操作</h3>
<p>Compare-And-Swap (CAS) 是构建自定义原子操作的基础：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 原子乘法实现</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">atomicMul</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">assumed</span><span class="p">;</span>

<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">assumed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old</span><span class="p">;</span>
<span class="w">        </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicCAS</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">assumed</span><span class="p">,</span><span class="w"> </span><span class="n">assumed</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">assumed</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">old</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">old</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 原子除法实现（需要处理除零）</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">atomicDiv</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">divisor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">divisor</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">addr_as_uint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">addr_as_uint</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">assumed</span><span class="p">;</span>

<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">assumed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">old_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__uint_as_float</span><span class="p">(</span><span class="n">assumed</span><span class="p">);</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">new_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_value</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">divisor</span><span class="p">;</span>
<span class="w">        </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicCAS</span><span class="p">(</span><span class="n">addr_as_uint</span><span class="p">,</span><span class="w"> </span><span class="n">assumed</span><span class="p">,</span>
<span class="w">                       </span><span class="n">__float_as_uint</span><span class="p">(</span><span class="n">new_value</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">assumed</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">old</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__uint_as_float</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="722">7.2.2 复杂数据结构的原子操作</h3>
<p>对于复杂数据类型，可以使用128位原子操作：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 128位原子CAS (仅compute capability 7.0+)</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Complex</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">real</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">imag</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">magnitude</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">phase</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">atomicUpdateComplex</span><span class="p">(</span><span class="n">Complex</span><span class="o">*</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 将128位数据作为两个64位整数处理</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="w"> </span><span class="n">addr_as_ull</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">old_low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr_as_ull</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">old_high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr_as_ull</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">new_low</span><span class="p">,</span><span class="w"> </span><span class="n">new_high</span><span class="p">;</span>

<span class="w">    </span><span class="n">Complex</span><span class="w"> </span><span class="n">old_complex</span><span class="p">,</span><span class="w"> </span><span class="n">assumed_complex</span><span class="p">;</span>

<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 重构旧值</span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">assumed_complex</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">old_low</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Complex</span><span class="p">));</span>

<span class="w">        </span><span class="c1">// 计算新值</span>
<span class="w">        </span><span class="n">Complex</span><span class="w"> </span><span class="n">updated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeUpdate</span><span class="p">(</span><span class="n">assumed_complex</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_low</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">updated</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">));</span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_high</span><span class="p">,</span><span class="w"> </span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">updated</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">));</span>

<span class="w">        </span><span class="c1">// 原子更新</span>
<span class="w">        </span><span class="n">old_low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr_as_ull</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">old_low</span><span class="p">,</span><span class="w"> </span><span class="n">new_low</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">old_low</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">assumed_complex</span><span class="p">.</span><span class="n">low</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">old_high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr_as_ull</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">old_high</span><span class="p">,</span><span class="w"> </span><span class="n">new_high</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">old_low</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">assumed_complex</span><span class="p">.</span><span class="n">low</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">old_high</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">assumed_complex</span><span class="p">.</span><span class="n">high</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="723">7.2.3 无锁数据结构原语</h3>
<p>实现无锁栈：</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">LockFreeStack</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">top</span><span class="p">;</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">push</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">new_node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">old_top</span><span class="p">;</span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">old_top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">top</span><span class="p">;</span>
<span class="w">            </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_top</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">top</span><span class="p">,</span><span class="w"> </span>
<span class="w">                          </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">old_top</span><span class="p">,</span>
<span class="w">                          </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">new_node</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span>
<span class="w">                 </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">old_top</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">pop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">old_top</span><span class="p">;</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">new_top</span><span class="p">;</span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">old_top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">top</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">old_top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span>
<span class="w">            </span><span class="n">new_top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_top</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">top</span><span class="p">,</span>
<span class="w">                          </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">old_top</span><span class="p">,</span>
<span class="w">                          </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">new_top</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span>
<span class="w">                 </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">old_top</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">old_top</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h2 id="73">7.3 内存栅栏与一致性模型</h2>
<h3 id="731-cuda">7.3.1 CUDA内存一致性模型</h3>
<p>CUDA采用弱内存一致性模型，需要显式的同步来保证内存操作的顺序：</p>
<div class="codehilite"><pre><span></span><code>线程内顺序：程序顺序
线程间顺序：需要同步原语
  ↓
内存操作重排序规则：

1. Load-Load: 可重排序
2. Load-Store: 可重排序  
3. Store-Load: 可重排序
4. Store-Store: 可重排序
  ↓
需要栅栏指令来防止重排序
</code></pre></div>

<h3 id="732">7.3.2 栅栏指令层次</h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// 线程栅栏 - 保证单个线程内的内存操作顺序</span>
<span class="nf">__threadfence</span><span class="p">();</span><span class="w">        </span><span class="c1">// 设备范围</span>
<span class="nf">__threadfence_block</span><span class="p">();</span><span class="w">  </span><span class="c1">// 块范围</span>
<span class="nf">__threadfence_system</span><span class="p">();</span><span class="w"> </span><span class="c1">// 系统范围</span>

<span class="c1">// 示例：生产者-消费者模式</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">producer</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_value</span><span class="p">();</span>
<span class="w">    </span><span class="nf">__threadfence</span><span class="p">();</span><span class="w">  </span><span class="c1">// 确保data写入在flag之前完成</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 通知消费者数据已准备好</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">consumer</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">flag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 等待标志</span>
<span class="w">    </span><span class="nf">__threadfence</span><span class="p">();</span><span class="w">     </span><span class="c1">// 确保读取flag后再读取data</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
<span class="w">    </span><span class="n">process</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="733">7.3.3 内存栅栏的性能影响</h3>
<p>不同栅栏的开销：</p>
<div class="codehilite"><pre><span></span><code>栅栏类型                 延迟(cycles)   影响范围
------------------------------------------------
__threadfence_block()    ~30          块内所有线程
__threadfence()          ~200         设备所有线程
__threadfence_system()   ~500         系统所有设备
</code></pre></div>

<p>优化策略：</p>
<ol>
<li>尽量使用最小范围的栅栏</li>
<li>批量操作后使用单个栅栏</li>
<li>使用协作组的同步原语替代</li>
</ol>
<h3 id="734-">7.3.4 发布-获取语义</h3>
<p>CUDA 11.0+支持C++11风格的内存序：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 发布语义 - 之前的所有写操作对其他线程可见</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">release_store</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nf">__threadfence</span><span class="p">();</span>
<span class="w">    </span><span class="n">atomicExch</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 获取语义 - 之后的所有读操作看到最新值</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">acquire_load</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 原子读</span>
<span class="w">    </span><span class="nf">__threadfence</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 顺序一致性</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">seq_cst_operation</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nf">__threadfence</span><span class="p">();</span>
<span class="w">    </span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="nf">__threadfence</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="74">7.4 自旋锁与无锁算法</h2>
<h3 id="741">7.4.1 高效自旋锁实现</h3>
<p>基础自旋锁：</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">SpinLock</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">acquire</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 自旋等待</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">release</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">atomicExch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<p>优化的自旋锁（减少原子操作）：</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">OptimizedSpinLock</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">acquire</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 先用普通读检查</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lock</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// 尝试获取锁</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// 指数退避</span>
<span class="w">            </span><span class="n">__nanosleep</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">7</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">release</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nf">__threadfence</span><span class="p">();</span><span class="w">  </span><span class="c1">// 确保之前的操作完成</span>
<span class="w">        </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">         </span><span class="c1">// 普通写即可</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="cp">### 7.4.2 票据锁（Ticket Lock）</span>

<span class="n">票据锁提供公平性保证</span><span class="err">：</span>

<span class="err">```</span><span class="n">cuda</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">TicketLock</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ticket</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">serving</span><span class="p">;</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">acquire</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">my_ticket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ticket</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">serving</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">my_ticket</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 自旋等待自己的票号</span>
<span class="w">            </span><span class="nf">__threadfence_block</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">release</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nf">__threadfence</span><span class="p">();</span>
<span class="w">        </span><span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serving</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="743-mcs">7.4.3 MCS锁（可扩展性更好）</h3>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">MCSNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">locked</span><span class="p">;</span>
<span class="w">    </span><span class="n">MCSNode</span><span class="o">*</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">MCSLock</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">MCSNode</span><span class="o">*</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">acquire</span><span class="p">(</span><span class="n">MCSNode</span><span class="o">*</span><span class="w"> </span><span class="n">my_node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">my_node</span><span class="o">-&gt;</span><span class="n">locked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">my_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span>

<span class="w">        </span><span class="n">MCSNode</span><span class="o">*</span><span class="w"> </span><span class="n">predecessor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">MCSNode</span><span class="o">*</span><span class="p">)</span><span class="n">atomicExch</span><span class="p">(</span>
<span class="w">            </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tail</span><span class="p">,</span><span class="w"> </span>
<span class="w">            </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">my_node</span>
<span class="w">        </span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">predecessor</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">predecessor</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_node</span><span class="p">;</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">my_node</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// 自旋在自己的节点上</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">release</span><span class="p">(</span><span class="n">MCSNode</span><span class="o">*</span><span class="w"> </span><span class="n">my_node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">my_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tail</span><span class="p">,</span>
<span class="w">                         </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">my_node</span><span class="p">,</span>

<span class="w">                         </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">my_node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">my_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nullptr</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">my_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">locked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="744">7.4.4 无锁算法设计原则</h3>
<ol>
<li><strong>ABA问题及解决方案</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 使用版本号解决ABA问题</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">VersionedPointer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">version</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">compareAndSwap</span><span class="p">(</span><span class="n">VersionedPointer</span><span class="o">*</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span>
<span class="w">                               </span><span class="n">VersionedPointer</span><span class="w"> </span><span class="n">expected</span><span class="p">,</span>
<span class="w">                               </span><span class="n">VersionedPointer</span><span class="w"> </span><span class="n">desired</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="w"> </span><span class="n">addr_as_ull</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">expected_ull</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">expected</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">desired_ull</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">desired</span><span class="p">;</span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicCAS</span><span class="p">(</span><span class="n">addr_as_ull</span><span class="p">,</span><span class="w"> </span><span class="n">expected_ull</span><span class="p">,</span><span class="w"> </span><span class="n">desired_ull</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">expected_ull</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<ol start="2">
<li><strong>内存管理与危险指针</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 危险指针机制防止过早释放</span>
<span class="n">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">MAX_THREADS</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">HazardPointers</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">hazard</span><span class="p">[</span><span class="n">MAX_THREADS</span><span class="p">];</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">protect</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">**</span><span class="w"> </span><span class="n">ptr_location</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">ptr_location</span><span class="p">;</span>
<span class="w">            </span><span class="n">hazard</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>
<span class="w">            </span><span class="nf">__threadfence</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">*</span><span class="n">ptr_location</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">clear</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">hazard</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_safe_to_delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_THREADS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hazard</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="745">7.4.5 无锁队列实现</h3>
<p>Michael &amp; Scott无锁队列：</p>
<div class="codehilite"><pre><span></span><code><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">LockFreeQueue</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">T</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">enqueue</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">new_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocate_node</span><span class="p">();</span>
<span class="w">        </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="w">            </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">last</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">next</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span>
<span class="w">                                 </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">new_node</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">atomicCAS</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tail</span><span class="p">,</span>
<span class="w">                                 </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">last</span><span class="p">,</span>
<span class="w">                                 </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">new_node</span><span class="p">);</span>
<span class="w">                        </span><span class="k">break</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">atomicCAS</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tail</span><span class="p">,</span>
<span class="w">                             </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">last</span><span class="p">,</span>
<span class="w">                             </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">next</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">dequeue</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">            </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="w">            </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">last</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">next</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">  </span><span class="c1">// 队列为空</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="n">atomicCAS</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tail</span><span class="p">,</span>
<span class="w">                             </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">last</span><span class="p">,</span>
<span class="w">                             </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">next</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="o">*</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">head</span><span class="p">,</span>
<span class="w">                                 </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">first</span><span class="p">,</span>
<span class="w">                                 </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="o">==</span>
<span class="w">                        </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">free_node</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h2 id="75">7.5 案例：高并发哈希表实现</h2>
<h3 id="751">7.5.1 设计目标与挑战</h3>
<p>在自动驾驶场景中，高并发哈希表用于：</p>
<ul>
<li>实时点云特征匹配</li>
<li>动态对象跟踪</li>
<li>传感器数据关联</li>
</ul>
<p>设计挑战：</p>
<ol>
<li>极高的并发度（数千线程同时访问）</li>
<li>动态扩容需求</li>
<li>负载均衡</li>
<li>内存效率</li>
</ol>
<h3 id="752">7.5.2 分段锁哈希表</h3>
<div class="codehilite"><pre><span></span><code><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">Key</span><span class="p">,</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="n">Value</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NUM_SEGMENTS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="o">&gt;</span>
<span class="n">class</span><span class="w"> </span><span class="n">ConcurrentHashMap</span><span class="w"> </span><span class="p">{</span>
<span class="n">private</span><span class="o">:</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Entry</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">        </span><span class="n">Value</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="n">Entry</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">valid</span><span class="p">;</span><span class="w">  </span><span class="c1">// 0: empty, 1: valid, -1: deleted</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Segment</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Entry</span><span class="o">**</span><span class="w"> </span><span class="n">buckets</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">bucket_count</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">        </span><span class="n">SpinLock</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">Segment</span><span class="w"> </span><span class="n">segments</span><span class="p">[</span><span class="n">NUM_SEGMENTS</span><span class="p">];</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">hash1</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// MurmurHash3的简化版本</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mh">0x85ebca6b</span><span class="p">;</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">13</span><span class="p">;</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mh">0xc2b2ae35</span><span class="p">;</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">get_segment</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">hash1</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">NUM_SEGMENTS</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="n">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">seg_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_segment</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="n">Segment</span><span class="o">&amp;</span><span class="w"> </span><span class="n">seg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">segments</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">];</span>

<span class="w">        </span><span class="n">seg</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">bucket_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash1</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">seg</span><span class="p">.</span><span class="n">bucket_count</span><span class="p">;</span>
<span class="w">        </span><span class="n">Entry</span><span class="o">*</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seg</span><span class="p">.</span><span class="n">buckets</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// 查找是否已存在</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">entry</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">valid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">seg</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">  </span><span class="c1">// 键已存在</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 插入新条目</span>
<span class="w">        </span><span class="n">Entry</span><span class="o">*</span><span class="w"> </span><span class="n">new_entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocate_entry</span><span class="p">();</span>
<span class="w">        </span><span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">        </span><span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seg</span><span class="p">.</span><span class="n">buckets</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">];</span>
<span class="w">        </span><span class="n">new_entry</span><span class="o">-&gt;</span><span class="n">valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="n">seg</span><span class="p">.</span><span class="n">buckets</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_entry</span><span class="p">;</span>
<span class="w">        </span><span class="n">seg</span><span class="p">.</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 检查是否需要扩容</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">seg</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">seg</span><span class="p">.</span><span class="n">bucket_count</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.75</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">resize_segment</span><span class="p">(</span><span class="n">seg_idx</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">seg</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">seg_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_segment</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="n">Segment</span><span class="o">&amp;</span><span class="w"> </span><span class="n">seg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">segments</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// 读操作可以更宽松</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">bucket_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash1</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">seg</span><span class="p">.</span><span class="n">bucket_count</span><span class="p">;</span>
<span class="w">        </span><span class="n">Entry</span><span class="o">*</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seg</span><span class="p">.</span><span class="n">buckets</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">];</span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">entry</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">valid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="o">*</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">remove</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">seg_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_segment</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="n">Segment</span><span class="o">&amp;</span><span class="w"> </span><span class="n">seg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">segments</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">];</span>

<span class="w">        </span><span class="n">seg</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">bucket_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash1</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">seg</span><span class="p">.</span><span class="n">bucket_count</span><span class="p">;</span>
<span class="w">        </span><span class="n">Entry</span><span class="o">**</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">seg</span><span class="p">.</span><span class="n">buckets</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">];</span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Entry</span><span class="o">*</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">valid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 标记删除</span>
<span class="w">                </span><span class="n">seg</span><span class="p">.</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
<span class="w">                </span><span class="n">seg</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">seg</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="753">7.5.3 无锁哈希表实现</h3>
<div class="codehilite"><pre><span></span><code><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">Key</span><span class="p">,</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="n">Value</span><span class="o">&gt;</span>
<span class="n">class</span><span class="w"> </span><span class="n">LockFreeHashMap</span><span class="w"> </span><span class="p">{</span>
<span class="n">private</span><span class="o">:</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">        </span><span class="n">Value</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">version</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Bucket</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">version</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">Bucket</span><span class="o">*</span><span class="w"> </span><span class="n">buckets</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">bucket_count</span><span class="p">;</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// CityHash的GPU版本</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">        </span><span class="n">k</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">33</span><span class="p">;</span>
<span class="w">        </span><span class="n">k</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mh">0xff51afd7ed558ccd</span><span class="p">;</span>
<span class="w">        </span><span class="n">k</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">33</span><span class="p">;</span>
<span class="w">        </span><span class="n">k</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mh">0xc4ceb9fe1a85ec53</span><span class="p">;</span>
<span class="w">        </span><span class="n">k</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">33</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="n">k</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="n">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">bucket_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">bucket_count</span><span class="p">;</span>

<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">new_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocate_node</span><span class="p">();</span>
<span class="w">        </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">        </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buckets</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">].</span><span class="n">head</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// 检查键是否已存在</span>
<span class="w">            </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">free_node</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// 尝试插入</span>
<span class="w">            </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buckets</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">].</span><span class="n">head</span><span class="p">,</span>
<span class="w">                         </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">head</span><span class="p">,</span>
<span class="w">                         </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">new_node</span><span class="p">)</span><span class="w"> </span><span class="o">==</span>
<span class="w">                </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buckets</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">].</span><span class="n">version</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">bucket_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">bucket_count</span><span class="p">;</span>

<span class="w">        </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buckets</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">].</span><span class="n">head</span><span class="p">;</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="o">*</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="754-cuckoo">7.5.4 Cuckoo哈希表（高速查找）</h3>
<div class="codehilite"><pre><span></span><code><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">Key</span><span class="p">,</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="n">Value</span><span class="o">&gt;</span>
<span class="n">class</span><span class="w"> </span><span class="n">CuckooHashMap</span><span class="w"> </span><span class="p">{</span>
<span class="n">private</span><span class="o">:</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Entry</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">        </span><span class="n">Value</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">version</span><span class="p">;</span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">occupied</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">Entry</span><span class="o">*</span><span class="w"> </span><span class="n">table1</span><span class="p">;</span>
<span class="w">    </span><span class="n">Entry</span><span class="o">*</span><span class="w"> </span><span class="n">table2</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">table_size</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MAX_EVICTIONS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">hash1</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x9e3779b9</span><span class="p">;</span><span class="w">  </span><span class="c1">// 黄金比例哈希</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">hash2</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x517cc1b7</span><span class="p">;</span><span class="w">  </span><span class="c1">// 另一个质数</span>
<span class="w">    </span><span class="p">}</span>

<span class="n">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash1</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">table_size</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash2</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">table_size</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 尝试插入第一个表</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table1</span><span class="p">[</span><span class="n">h1</span><span class="p">].</span><span class="n">occupied</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">table1</span><span class="p">[</span><span class="n">h1</span><span class="p">].</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">            </span><span class="n">table1</span><span class="p">[</span><span class="n">h1</span><span class="p">].</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">            </span><span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table1</span><span class="p">[</span><span class="n">h1</span><span class="p">].</span><span class="n">version</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 尝试插入第二个表</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table2</span><span class="p">[</span><span class="n">h2</span><span class="p">].</span><span class="n">occupied</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">table2</span><span class="p">[</span><span class="n">h2</span><span class="p">].</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">            </span><span class="n">table2</span><span class="p">[</span><span class="n">h2</span><span class="p">].</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">            </span><span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table2</span><span class="p">[</span><span class="n">h2</span><span class="p">].</span><span class="n">version</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Cuckoo路径驱逐</span>
<span class="w">        </span><span class="n">Entry</span><span class="w"> </span><span class="n">evicted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span>
<span class="w">        </span><span class="n">Entry</span><span class="o">*</span><span class="w"> </span><span class="n">current_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table1</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h1</span><span class="p">;</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_EVICTIONS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Entry</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current_table</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
<span class="w">            </span><span class="n">current_table</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">evicted</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">occupied</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">            </span><span class="n">evicted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// 切换到另一个表</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current_table</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">table1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">current_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table2</span><span class="p">;</span>
<span class="w">                </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash2</span><span class="p">(</span><span class="n">evicted</span><span class="p">.</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">table_size</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">current_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table1</span><span class="p">;</span>
<span class="w">                </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash1</span><span class="p">(</span><span class="n">evicted</span><span class="p">.</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">table_size</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 需要重新哈希</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash1</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">table_size</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash2</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">table_size</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 最多两次内存访问</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">table1</span><span class="p">[</span><span class="n">h1</span><span class="p">].</span><span class="n">occupied</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">table1</span><span class="p">[</span><span class="n">h1</span><span class="p">].</span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table1</span><span class="p">[</span><span class="n">h1</span><span class="p">].</span><span class="n">value</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">table2</span><span class="p">[</span><span class="n">h2</span><span class="p">].</span><span class="n">occupied</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">table2</span><span class="p">[</span><span class="n">h2</span><span class="p">].</span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table2</span><span class="p">[</span><span class="n">h2</span><span class="p">].</span><span class="n">value</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="755">7.5.5 性能优化策略</h3>
<ol>
<li><strong>SIMD友好的探测</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 使用向量化load进行批量查找</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">batch_find</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">keys</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="o">*</span><span class="w"> </span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 利用向量化指令一次加载多个键</span>
<span class="w">    </span><span class="kt">uint4</span><span class="o">*</span><span class="w"> </span><span class="n">vec_keys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint4</span><span class="o">*</span><span class="p">)</span><span class="n">keys</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint4</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec_keys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// 并行计算4个哈希值</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">batch</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">bucket_count</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">batch</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">bucket_count</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">batch</span><span class="p">.</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">bucket_count</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">batch</span><span class="p">.</span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">bucket_count</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 预取bucket数据</span>
<span class="w">        </span><span class="n">__builtin_prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buckets</span><span class="p">[</span><span class="n">h0</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">        </span><span class="n">__builtin_prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buckets</span><span class="p">[</span><span class="n">h1</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">        </span><span class="n">__builtin_prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buckets</span><span class="p">[</span><span class="n">h2</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">        </span><span class="n">__builtin_prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buckets</span><span class="p">[</span><span class="n">h3</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 并行查找</span>
<span class="w">        </span><span class="n">find_single</span><span class="p">(</span><span class="n">batch</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">]);</span>
<span class="w">        </span><span class="n">find_single</span><span class="p">(</span><span class="n">batch</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">        </span><span class="n">find_single</span><span class="p">(</span><span class="n">batch</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">        </span><span class="n">find_single</span><span class="p">(</span><span class="n">batch</span><span class="p">.</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">3</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<ol start="2">
<li><strong>内存池管理</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// 线程本地内存池减少分配开销</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">POOL_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ThreadLocalPool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">pool</span><span class="p">[</span><span class="n">POOL_SIZE</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">free_list</span><span class="p">[</span><span class="n">POOL_SIZE</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">free_count</span><span class="p">;</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">POOL_SIZE</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">free_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">free_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">POOL_SIZE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">allocate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">free_count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pool</span><span class="p">[</span><span class="n">free_list</span><span class="p">[</span><span class="o">--</span><span class="n">free_count</span><span class="p">]];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// 需要全局分配</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">deallocate</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">pool</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">POOL_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">free_list</span><span class="p">[</span><span class="n">free_count</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="756">7.5.6 实际应用：点云特征匹配</h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// 用于自动驾驶中的实时点云配准</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">PointFeature</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">float3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">descriptor</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span><span class="w">  </span><span class="c1">// FPFH特征</span>
<span class="p">};</span>

<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">match_point_features</span><span class="p">(</span>
<span class="w">    </span><span class="n">PointFeature</span><span class="o">*</span><span class="w"> </span><span class="n">source_cloud</span><span class="p">,</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">source_count</span><span class="p">,</span>
<span class="w">    </span><span class="n">PointFeature</span><span class="o">*</span><span class="w"> </span><span class="n">target_cloud</span><span class="p">,</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">target_count</span><span class="p">,</span>
<span class="w">    </span><span class="n">LockFreeHashMap</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">feature_map</span><span class="p">,</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">matches</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tid</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">source_count</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="n">PointFeature</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_cloud</span><span class="p">[</span><span class="n">tid</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// 计算特征哈希</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">feature_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">feature_hash</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">__float_as_uint</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">descriptor</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 在哈希表中查找匹配</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">match_idx</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">feature_map</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">feature_hash</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">match_idx</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 验证空间一致性</span>
<span class="w">        </span><span class="kt">float3</span><span class="w"> </span><span class="n">target_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target_cloud</span><span class="p">[</span><span class="n">match_idx</span><span class="p">].</span><span class="n">position</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">target_pos</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dist</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.1f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 10cm阈值</span>
<span class="w">            </span><span class="n">matches</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">match_idx</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="_1">本章小结</h2>
<p>本章深入探讨了CUDA中的原子操作和同步机制：</p>
<p><strong>关键概念</strong>：</p>
<ol>
<li>原子操作通过硬件保证多线程环境下的操作原子性</li>
<li>内存栅栏提供了不同范围的内存一致性保证</li>
<li>无锁算法通过CAS等原语避免锁的开销</li>
<li>高并发数据结构需要权衡吞吐量、延迟和内存效率</li>
</ol>
<p><strong>性能公式</strong>：</p>
<ul>
<li>原子操作吞吐量：<code>T = min(内存带宽 / 操作大小, 原子单元数量 × 频率)</code></li>
<li>锁竞争开销：<code>O = 串行化延迟 × 冲突概率 × 线程数</code></li>
<li>无锁算法复杂度：<code>重试次数 = O(线程数 × 竞争强度)</code></li>
</ul>
<p><strong>优化要点</strong>：</p>
<ol>
<li>批量化原子操作减少竞争</li>
<li>使用合适的同步粒度</li>
<li>选择适合访问模式的数据结构</li>
<li>利用warp级原语优化</li>
</ol>
<h2 id="_2">练习题</h2>
<h3 id="_3">基础题</h3>
<ol>
<li><strong>原子操作选择</strong>
   实现一个计数器，统计数组中大于阈值的元素个数。比较使用原子操作和归约的性能差异。</li>
</ol>
<details markdown="block">
   <summary markdown="off">答案</summary>

   对于大规模数据，先在warp或block内归约，再使用原子操作更新全局计数器。这样可以将原子操作次数从N减少到N/32或N/blockSize。
   </details>
<ol start="2">
<li><strong>内存栅栏应用</strong>
   设计一个双缓冲系统，保证写入缓冲区的数据对读取线程完全可见。</li>
</ol>
<details markdown="block">
   <summary markdown="off">答案</summary>

   写入完成后使用__threadfence()，然后更新缓冲区索引。读取时先读索引，再使用__threadfence()确保后续读取看到完整数据。
   </details>
<ol start="3">
<li><strong>自旋锁优化</strong>
   改进基础自旋锁，添加退避机制减少总线竞争。</li>
</ol>
<details markdown="block">
   <summary markdown="off">答案</summary>

   使用指数退避：初始等待时间短，每次失败后加倍等待时间，设置最大等待时间上限。可以根据线程ID添加随机性避免同步冲突。
   </details>
<h3 id="_4">挑战题</h3>
<ol start="4">
<li><strong>无锁内存分配器</strong>
   设计一个适用于GPU的无锁内存分配器，支持可变大小的内存块分配。</li>
</ol>
<p>提示：考虑使用多个大小类的内存池</p>
<details markdown="block">
   <summary markdown="off">答案</summary>

   使用分级内存池，每个大小类维护一个无锁栈。分配时根据请求大小选择合适的池，使用CAS操作管理空闲列表。需要处理内存碎片和池间迁移。
   </details>
<ol start="5">
<li><strong>读写锁实现</strong>
   实现一个读者优先的读写锁，允许多个读者同时访问，但写者独占。</li>
</ol>
<p>提示：使用原子计数器跟踪读者数量</p>
<details markdown="block">
   <summary markdown="off">答案</summary>

   使用两个原子变量：readers_count和writer_flag。读者通过原子增加readers_count获取锁，写者需要等待readers_count为0并设置writer_flag。需要处理饥饿问题。
   </details>
<ol start="6">
<li><strong>并发B+树</strong>
   设计一个GPU友好的并发B+树，支持高效的范围查询。</li>
</ol>
<p>提示：考虑使用乐观并发控制</p>
<details markdown="block">
   <summary markdown="off">答案</summary>

   使用版本号实现乐观读，只在修改时加锁。叶节点使用链表连接支持范围扫描。内部节点使用原子CAS更新指针，叶节点使用细粒度锁。
   </details>
<h3 id="_5">开放性思考题</h3>
<ol start="7">
<li><strong>原子操作 vs 事务内存</strong>
   如果GPU支持硬件事务内存（HTM），会如何改变并发编程模型？分析优缺点。</li>
</ol>
<details markdown="block">
   <summary markdown="off">答案</summary>

   HTM可以简化编程模型，自动处理冲突和回滚。但GPU的大规模并行特性可能导致频繁冲突，事务大小限制也是挑战。混合使用HTM和传统同步可能是最佳方案。
   </details>
<ol start="8">
<li><strong>跨设备原子操作</strong>
   设计一个支持多GPU原子操作的系统，考虑PCIe延迟和带宽限制。</li>
</ol>
<details markdown="block">
   <summary markdown="off">答案</summary>

   可以使用层次化设计：设备内原子操作直接执行，跨设备操作通过主机端协调或使用GPUDirect RDMA。批量化跨设备操作，使用版本向量保证一致性。
   </details>
<h2 id="_6">常见陷阱与错误</h2>
<ol>
<li>
<p><strong>死锁</strong>
   - 错误：多个锁的获取顺序不一致
   - 正确：始终按相同顺序获取多个锁</p>
</li>
<li>
<p><strong>ABA问题</strong>
   - 错误：仅比较指针值
   - 正确：使用版本号或标记指针</p>
</li>
<li>
<p><strong>内存序错误</strong>
   - 错误：忽略内存重排序
   - 正确：正确使用内存栅栏</p>
</li>
<li>
<p><strong>原子操作滥用</strong>
   - 错误：对所有共享变量使用原子操作
   - 正确：分析访问模式，必要时才使用</p>
</li>
<li>
<p><strong>活锁</strong>
   - 错误：无限重试失败的CAS
   - 正确：添加退避机制或重试限制</p>
</li>
</ol>
<h2 id="_7">最佳实践检查清单</h2>
<ul>
<li>[ ] 原子操作是否已批量化？</li>
<li>[ ] 是否选择了正确的同步粒度？</li>
<li>[ ] 内存栅栏范围是否最小化？</li>
<li>[ ] 是否处理了ABA问题？</li>
<li>[ ] 无锁算法是否有退避机制？</li>
<li>[ ] 是否避免了false sharing？</li>
<li>[ ] 内存分配是否优化？</li>
<li>[ ] 是否使用了合适的哈希函数？</li>
<li>[ ] 并发数据结构是否支持扩展？</li>
<li>[ ] 是否有性能监控和调试机制？
```</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter6.html" class="nav-link prev">← 第6章：Warp级编程与协作组</a><a href="chapter8.html" class="nav-link next">第8章：PTX内联与底层优化 →</a></nav>
        </main>
    </div>
</body>
</html>