<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第6章：Warp级编程与协作组</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">CUDA 高性能编程实战教程</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第1章：CUDA硬件架构深度剖析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第2章：CUDA编程模型与执行模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第3章：全局内存优化策略</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第4章：共享内存与Bank Conflict</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第5章：寄存器优化与常量内存</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第6章：Warp级编程与协作组</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第7章：原子操作与同步原语</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第8章：PTX内联与底层优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第9章：张量核心与混合精度计算</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第10章：CUTLASS深度解析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第11章：激光雷达点云处理加速</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第12章：多传感器融合的并行化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第13章：实时语义分割与实例分割</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第14章：路径规划与轨迹优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第15章：视觉SLAM的GPU加速</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第16章：机械臂运动规划</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter17.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第17章：强化学习推理加速</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter18.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第18章：大规模点云重建与网格化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter19.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第19章：多GPU编程与扩展</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter20.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第20章：CUDA Graph与内核融合</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter21.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第21章：嵌入式GPU开发（Jetson）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter22.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第22章：稀疏计算与动态稀疏</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter23.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第23章：量化与低精度计算</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter24.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第24章：新一代GPU特性展望</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter25.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第25章：性能分析与调优方法论</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter26.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第26章：CUDA调试技术与错误处理</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter27.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第27章：开发环境与工具链配置</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="6warp">第6章：Warp级编程与协作组</h1>
<p>在前面的章节中，我们已经掌握了CUDA的基础编程模型和内存优化技术。本章将深入探讨CUDA编程的核心概念之一：warp级编程。Warp是GPU执行的基本单位，理解并利用warp级原语可以实现极致的性能优化。我们将学习如何使用shuffle、vote等warp内在函数，掌握协作组（Cooperative Groups）这一强大的编程抽象，实现高效的并行算法，并通过无锁数据结构的案例展示这些技术在实际场景中的应用。</p>
<h2 id="61-warp">6.1 Warp内在函数</h2>
<h3 id="611-warpsimt">6.1.1 Warp概念与SIMT执行模型</h3>
<p>在NVIDIA GPU中，warp是硬件调度和执行的基本单位，包含32个线程。这32个线程以SIMT（Single Instruction Multiple Thread）方式执行，即同一时刻执行相同的指令，但操作不同的数据。</p>
<div class="codehilite"><pre><span></span><code>Warp执行模型：
┌─────────────────────────────────────────┐
│           Warp (32 threads)             │
├─────────────────────────────────────────┤
│ T0 │ T1 │ T2 │ ... │ T30│ T31│         │
├─────────────────────────────────────────┤
│      同一条指令，不同数据                │
│      Program Counter (PC)               │
└─────────────────────────────────────────┘
</code></pre></div>

<p>理解warp的执行特性对于性能优化至关重要：</p>
<ol>
<li><strong>锁步执行</strong>：同一warp内的线程共享指令单元，必须执行相同的指令</li>
<li><strong>分支分歧</strong>：当warp内线程执行不同分支时，会串行执行各分支，降低效率</li>
<li><strong>活跃掩码</strong>：每个线程都有一个活跃位，标识该线程是否参与当前指令的执行</li>
</ol>
<h3 id="612-shuffle">6.1.2 Shuffle指令族详解</h3>
<p>Shuffle指令允许warp内线程直接交换寄存器数据，无需通过共享内存，具有极低的延迟（仅1个时钟周期）。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 基本shuffle操作</span>
<span class="n">__shfl_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">srcLane</span><span class="p">);</span><span class="w">        </span><span class="c1">// 从指定lane读取</span>
<span class="n">__shfl_up_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">delta</span><span class="p">);</span><span class="w">       </span><span class="c1">// 从lane_id-delta读取</span>
<span class="n">__shfl_down_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">delta</span><span class="p">);</span><span class="w">     </span><span class="c1">// 从lane_id+delta读取  </span>
<span class="n">__shfl_xor_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">laneMask</span><span class="p">);</span><span class="w">   </span><span class="c1">// 从lane_id^laneMask读取</span>
</code></pre></div>

<p>关键参数说明：</p>
<ul>
<li><code>mask</code>：32位掩码，指定参与操作的线程</li>
<li><code>var</code>：要交换的变量</li>
<li><code>srcLane/delta/laneMask</code>：源线程的计算方式</li>
</ul>
<p><strong>蝶形交换模式示例</strong>：</p>
<div class="codehilite"><pre><span></span><code>XOR模式 (laneMask=1)：
Lane: 0←→1, 2←→3, 4←→5, 6←→7, ...

XOR模式 (laneMask=2)：
Lane: 0←→2, 1←→3, 4←→6, 5←→7, ...

XOR模式 (laneMask=4)：
Lane: 0←→4, 1←→5, 2←→6, 3←→7, ...
</code></pre></div>

<p>Shuffle指令的典型应用场景：</p>
<ol>
<li><strong>Warp级归约</strong>：无需共享内存的快速归约</li>
<li><strong>数据广播</strong>：将一个线程的数据广播给其他线程</li>
<li><strong>矩阵转置</strong>：小矩阵的寄存器级转置</li>
<li><strong>前缀和计算</strong>：高效的扫描算法实现</li>
</ol>
<h3 id="613-vote">6.1.3 Vote指令族与分支优化</h3>
<p>Vote指令用于warp内线程间的条件检查和同步，主要包括：</p>
<div class="codehilite"><pre><span></span><code><span class="n">__all_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span><span class="p">);</span><span class="w">    </span><span class="c1">// 所有线程的predicate都为真时返回真</span>
<span class="n">__any_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span><span class="p">);</span><span class="w">    </span><span class="c1">// 任一线程的predicate为真时返回真</span>
<span class="n">__ballot_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span><span class="p">);</span><span class="w"> </span><span class="c1">// 返回32位掩码，每位表示对应线程的predicate值</span>
<span class="n">__activemask</span><span class="p">();</span><span class="w">                 </span><span class="c1">// 返回当前活跃线程的掩码</span>
</code></pre></div>

<p><strong>分支优化示例</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 低效的分支代码</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 可能造成warp分歧</span>
<span class="w">    </span><span class="n">expensive_computation</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 使用vote优化</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__ballot_sync</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span><span class="w"> </span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">limit</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mask</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 整个warp一起判断</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">expensive_computation</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="614-match">6.1.4 Match指令与动态协作</h3>
<p>Match指令（Compute Capability 7.0+）支持动态分组协作：</p>
<div class="codehilite"><pre><span></span><code><span class="n">__match_any_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w">   </span><span class="c1">// 返回具有相同value的线程掩码</span>
<span class="n">__match_all_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pred</span><span class="p">);</span><span class="w"> </span><span class="c1">// 检查所有线程是否具有相同value</span>
</code></pre></div>

<p>应用场景：</p>
<ul>
<li><strong>动态负载均衡</strong>：根据数据值动态分组处理</li>
<li><strong>稀疏数据处理</strong>：相同索引的线程协作</li>
<li><strong>直方图计算</strong>：相同bin的线程原子操作合并</li>
</ul>
<h2 id="62-cooperative-groups">6.2 协作组（Cooperative Groups）编程</h2>
<h3 id="621">6.2.1 协作组抽象层次</h3>
<p>协作组（Cooperative Groups）是CUDA 9.0引入的编程模型，提供了更灵活的线程协作抽象。它允许开发者定义和操作任意粒度的线程组，从单个线程到整个网格。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span>
<span class="n">namespace</span><span class="w"> </span><span class="n">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="p">;</span>

<span class="c1">// 协作组层次结构</span>
<span class="c1">// ┌─────────────────────────────┐</span>
<span class="c1">// │      Grid Group             │ 多个线程块</span>
<span class="c1">// ├─────────────────────────────┤</span>
<span class="c1">// │    Thread Block Group       │ 单个线程块</span>
<span class="c1">// ├─────────────────────────────┤</span>
<span class="c1">// │    Tiled Partition          │ 线程块的分区</span>
<span class="c1">// ├─────────────────────────────┤</span>
<span class="c1">// │    Coalesced Group          │ 动态活跃线程组</span>
<span class="c1">// └─────────────────────────────┘</span>
</code></pre></div>

<p>基本使用方法：</p>
<div class="codehilite"><pre><span></span><code><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 获取当前线程块</span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 创建warp大小的分区</span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block_tile</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">warp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 创建更小的分区</span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block_tile</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tile8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">warp</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 获取动态活跃组</span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">coalesced_group</span><span class="w"> </span><span class="n">active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">coalesced_threads</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="622">6.2.2 线程块级与网格级同步</h3>
<p>协作组提供了统一的同步接口：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 线程块级同步</span>
<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">blockSync</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 执行计算</span>
<span class="w">    </span><span class="n">compute_phase1</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 同步整个线程块</span>
<span class="w">    </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 继续计算</span>
<span class="w">    </span><span class="n">compute_phase2</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 网格级同步（需要特殊启动）</span>
<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gridSync</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">grid_group</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_grid</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 第一阶段计算</span>
<span class="w">    </span><span class="n">compute_global_phase1</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 同步整个网格（所有线程块）</span>
<span class="w">    </span><span class="n">grid</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 第二阶段计算</span>
<span class="w">    </span><span class="n">compute_global_phase2</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 网格级内核启动</span>
<span class="kt">void</span><span class="w"> </span><span class="n">launchGridSync</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">numBlocksPerSm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">numThreads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span>

<span class="w">    </span><span class="n">cudaOccupancyMaxActiveBlocksPerMultiprocessor</span><span class="p">(</span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">numBlocksPerSm</span><span class="p">,</span><span class="w"> </span><span class="n">gridSync</span><span class="p">,</span><span class="w"> </span><span class="n">numThreads</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">numSMs</span><span class="p">;</span>
<span class="w">    </span><span class="n">cudaDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numSMs</span><span class="p">,</span><span class="w"> </span><span class="n">cudaDevAttrMultiProcessorCount</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="kt">dim3</span><span class="w"> </span><span class="nf">gridDim</span><span class="p">(</span><span class="n">numSMs</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">numBlocksPerSm</span><span class="p">);</span>
<span class="w">    </span><span class="kt">dim3</span><span class="w"> </span><span class="nf">blockDim</span><span class="p">(</span><span class="n">numThreads</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">kernelArgs</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* args */</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">cudaLaunchCooperativeKernel</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">gridSync</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                </span><span class="nb">gridDim</span><span class="p">,</span><span class="w"> </span><span class="nb">blockDim</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                </span><span class="n">kernelArgs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="623">6.2.3 动态分区与重组</h3>
<p>协作组支持动态创建和重组线程组：</p>
<div class="codehilite"><pre><span></span><code><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">dynamicGroups</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 根据条件动态分组</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">group_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">  </span><span class="c1">// 分成3组</span>

<span class="w">    </span><span class="c1">// 标记分区</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">labeled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">labeled_partition</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">group_id</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 每个分组独立执行归约</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">group_id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 处理第一组数据</span>
<span class="w">        </span><span class="n">process_group_0</span><span class="p">(</span><span class="n">labeled</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">group_id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 处理第二组数据</span>
<span class="w">        </span><span class="n">process_group_1</span><span class="p">(</span><span class="n">labeled</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 处理第三组数据</span>
<span class="w">        </span><span class="n">process_group_2</span><span class="p">(</span><span class="n">labeled</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 使用binary_partition进行二分</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">binary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">binary_partition</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="w"> </span><span class="n">condition</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 偶数线程组和奇数线程组分别处理</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">even_thread_work</span><span class="p">(</span><span class="n">binary</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">odd_thread_work</span><span class="p">(</span><span class="n">binary</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="624-gpu">6.2.4 多GPU协作组</h3>
<p>协作组也支持多GPU编程模型：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 多GPU网格组</span>
<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">multiGPUKernel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">multi_grid_group</span><span class="w"> </span><span class="n">multi_grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_multi_grid</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 获取全局网格大小</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">global_rank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multi_grid</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">();</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">global_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multi_grid</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 全局数据分配</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">data_per_thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total_data</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">global_size</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">my_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">global_rank</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data_per_thread</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 局部计算</span>
<span class="w">    </span><span class="n">local_compute</span><span class="p">(</span><span class="n">my_offset</span><span class="p">,</span><span class="w"> </span><span class="n">data_per_thread</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 多GPU同步</span>
<span class="w">    </span><span class="n">multi_grid</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 全局归约或交换数据</span>
<span class="w">    </span><span class="n">global_reduction</span><span class="p">(</span><span class="n">multi_grid</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="63-warp">6.3 Warp级归约与扫描算法</h2>
<h3 id="631-warp">6.3.1 高效warp级归约实现</h3>
<p>Warp级归约是并行算法的基础构建块。利用shuffle指令可以实现无需共享内存的高效归约：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 基础warp归约（求和）</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">warpReduce</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 蝶形归约模式</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">val</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">__shfl_down_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 通用warp归约模板</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="n">Op</span><span class="o">&gt;</span>
<span class="kt">__device__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">warpReduceGeneric</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#pragma unroll</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">T</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_down_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span>
<span class="w">        </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 使用协作组的归约</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">Group</span><span class="o">&gt;</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">cgReduce</span><span class="p">(</span><span class="n">Group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lane</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">();</span>

<span class="w">    </span><span class="cp">#pragma unroll</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">val</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">shfl_down</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>归约执行过程示意</strong>：</p>
<div class="codehilite"><pre><span></span><code>步骤1 (offset=16): 线程0-15分别从线程16-31获取数据相加
步骤2 (offset=8):  线程0-7分别从线程8-15获取数据相加
步骤3 (offset=4):  线程0-3分别从线程4-7获取数据相加
步骤4 (offset=2):  线程0-1分别从线程2-3获取数据相加
步骤5 (offset=1):  线程0从线程1获取数据相加
结果: 线程0持有最终归约结果
</code></pre></div>

<h3 id="632">6.3.2 前缀和（扫描）算法</h3>
<p>前缀和是许多并行算法的关键组件，在自动驾驶的点云处理和路径规划中广泛应用：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Kogge-Stone并行前缀和算法</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">warpInclusiveScan</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lane</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">31</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#pragma unroll</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_up_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lane</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 独占扫描（exclusive scan）</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">warpExclusiveScan</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lane</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">31</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 先进行包含扫描</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">scan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">warpInclusiveScan</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 左移一位，第0个线程设为0</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__shfl_up_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">scan</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 分段扫描（segmented scan）</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">segmentedScan</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lane</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">31</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#pragma unroll</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_up_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_up_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">flag</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lane</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">val</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="633">6.3.3 分段归约与扫描</h3>
<p>在处理不规则数据（如稀疏矩阵、变长序列）时，分段操作尤为重要：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 分段归约示例：每个段独立求和</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">SegmentedReduce</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">operator</span><span class="p">()(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">segments</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">tid</span><span class="p">];</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">seg_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">segments</span><span class="p">[</span><span class="n">tid</span><span class="p">];</span>

<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 找出同一段的所有线程</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">same_segment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__match_any_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">seg_id</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 在同段内进行归约</span>
<span class="w">        </span><span class="n">cg</span><span class="o">::</span><span class="n">coalesced_group</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">labeled_partition</span><span class="p">(</span>
<span class="w">            </span><span class="n">cg</span><span class="o">::</span><span class="n">coalesced_threads</span><span class="p">(),</span><span class="w"> </span><span class="n">seg_id</span><span class="p">);</span>

<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cgReduce</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 只有每段的第一个线程返回结果</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="634">6.3.4 混合精度归约优化</h3>
<p>在深度学习推理中，混合精度计算可以显著提升性能：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// FP16到FP32的归约</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">mixedPrecisionReduce</span><span class="p">(</span><span class="n">__half2</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 先在FP16精度下归约</span>
<span class="w">    </span><span class="cp">#pragma unroll</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__hadd2</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">__shfl_down_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 转换为FP32进行最终累加</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__half2float</span><span class="p">(</span><span class="n">__low2half</span><span class="p">(</span><span class="n">val</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>
<span class="w">           </span><span class="n">__half2float</span><span class="p">(</span><span class="n">__high2half</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Kahan求和算法减少数值误差</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">kahanWarpReduce</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span><span class="w">  </span><span class="c1">// 补偿值</span>

<span class="w">    </span><span class="cp">#pragma unroll</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_down_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">        </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="64-independent-thread-scheduling">6.4 独立线程调度（Independent Thread Scheduling）</h2>
<h3 id="641-volta">6.4.1 Volta架构的调度改进</h3>
<p>从Volta架构（Compute Capability 7.0）开始，NVIDIA引入了独立线程调度（ITS），这是CUDA编程模型的重大改进：</p>
<p><strong>传统调度模型 vs ITS</strong>：</p>
<div class="codehilite"><pre><span></span><code>传统SIMT（Pre-Volta）：
┌──────────────────────────────┐
│  Warp: 32线程锁步执行         │
│  共享PC（程序计数器）          │
│  分支导致串行化               │
└──────────────────────────────┘

独立线程调度（Volta+）：
┌──────────────────────────────┐
│  Warp: 32线程独立PC和栈       │
│  细粒度同步控制               │
│  更好的分支效率               │
└──────────────────────────────┘
</code></pre></div>

<p>关键改进：</p>
<ol>
<li><strong>每线程程序计数器</strong>：每个线程有独立的PC和调用栈</li>
<li><strong>收敛栅栏</strong>：自动插入同步点保证正确性</li>
<li><strong>更灵活的执行</strong>：线程可以独立进度，提高硬件利用率</li>
</ol>
<h3 id="642">6.4.2 线程同步语义变化</h3>
<p>ITS改变了同步语义，需要显式同步来保证warp内线程的收敛：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Pre-Volta行为（隐式收敛）</span>
<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">oldBehavior</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 分支A</span>
<span class="w">        </span><span class="n">computeA</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 分支B</span>
<span class="w">        </span><span class="n">computeB</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// 隐式收敛点：所有线程自动同步</span>

<span class="w">    </span><span class="c1">// Warp内通信安全</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_sync</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Volta+行为（需要显式同步）</span>
<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">newBehavior</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__activemask</span><span class="p">();</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">computeA</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">computeB</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 必须显式同步才能保证收敛</span>
<span class="w">    </span><span class="n">__syncwarp</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 现在可以安全进行warp内通信</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="643">6.4.3 死锁预防策略</h3>
<p>ITS可能引入新的死锁场景，需要careful设计：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 潜在死锁示例</span>
<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">deadlockExample</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flag</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 线程0等待其他线程</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">flag</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">doWork</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 其他线程设置flag</span>
<span class="w">        </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">__syncwarp</span><span class="p">();</span><span class="w">  </span><span class="c1">// 死锁！线程0未到达同步点</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 正确的实现</span>
<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">correctImplementation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flag</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__activemask</span><span class="p">();</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 使用协作组避免死锁</span>
<span class="w">        </span><span class="n">cg</span><span class="o">::</span><span class="n">coalesced_group</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">coalesced_threads</span><span class="p">();</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 允许其他线程执行</span>
<span class="w">            </span><span class="n">__nanosleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">doWork</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">atomicExch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 仅同步参与的线程</span>
<span class="w">        </span><span class="n">__syncwarp</span><span class="p">(</span><span class="n">active</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// 排除线程0</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="644">6.4.4 性能影响与优化</h3>
<p>ITS对性能的影响需要case-by-case分析：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 利用ITS优化的生产者-消费者模式</span>
<span class="n">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">PRODUCER_MASK</span><span class="o">&gt;</span>
<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">producerConsumer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lane</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">31</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_producer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">lane</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PRODUCER_MASK</span><span class="p">;</span>

<span class="w">    </span><span class="kt">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="w">    </span><span class="kt">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ready_flags</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_producer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 生产者独立执行</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ITEMS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">produce_data</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">            </span><span class="n">buffer</span><span class="p">[</span><span class="n">lane</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">            </span><span class="nf">__threadfence_block</span><span class="p">();</span>
<span class="w">            </span><span class="n">atomicExch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ready_flags</span><span class="p">[</span><span class="n">lane</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// 继续生产，无需等待消费</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 消费者独立执行</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">producer_lane</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_producer</span><span class="p">(</span><span class="n">lane</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ITEMS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 等待数据就绪</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ready_flags</span><span class="p">[</span><span class="n">producer_lane</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="n">producer_lane</span><span class="p">];</span>
<span class="w">            </span><span class="n">consume_data</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 性能监测与分析</span>
<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">performanceAnalysis</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 测量分支分歧成本</span>
<span class="w">    </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock64</span><span class="p">();</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 奇数线程路径</span>
<span class="w">        </span><span class="n">expensive_path_a</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 偶数线程路径</span>
<span class="w">        </span><span class="n">expensive_path_b</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">__syncwarp</span><span class="p">();</span>
<span class="w">    </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock64</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 记录执行时间用于分析</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">divergence_cost</span><span class="p">[</span><span class="nb">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>优化建议</strong>：</p>
<ol>
<li><strong>最小化分支分歧</strong>：尽管ITS改善了分支效率，统一的控制流仍然最优</li>
<li><strong>显式同步</strong>：在需要warp收敛的地方使用<code>__syncwarp()</code></li>
<li><strong>利用独立进度</strong>：设计算法允许线程独立前进</li>
<li><strong>使用协作组</strong>：提供更清晰的同步语义</li>
</ol>
<h2 id="65">6.5 案例：无锁数据结构实现</h2>
<h3 id="651">6.5.1 无锁队列设计</h3>
<p>无锁数据结构在自动驾驶的实时系统中至关重要，可以避免传统锁带来的性能瓶颈。我们将实现一个高性能的无锁FIFO队列：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 无锁队列节点</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w">  </span><span class="c1">// 下一个节点的索引</span>
<span class="p">};</span>

<span class="c1">// 无锁FIFO队列</span>
<span class="n">class</span><span class="w"> </span><span class="n">LockFreeQueue</span><span class="w"> </span><span class="p">{</span>
<span class="n">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span><span class="w">          </span><span class="c1">// 节点池</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">free_list</span><span class="p">;</span><span class="w">       </span><span class="c1">// 空闲节点列表</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w">            </span><span class="c1">// 队列头索引</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w">            </span><span class="c1">// 队列尾索引</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">free_head</span><span class="p">;</span><span class="w">       </span><span class="c1">// 空闲列表头</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">capacity</span><span class="p">;</span>

<span class="n">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cap</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cap</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// 初始化空闲列表</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">capacity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">nodes</span><span class="p">[</span><span class="n">capacity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">].</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">        </span><span class="n">free_head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">allocate_node</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">old_head</span><span class="p">,</span><span class="w"> </span><span class="n">new_head</span><span class="p">;</span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">old_head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">free_head</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">old_head</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 没有空闲节点</span>

<span class="w">            </span><span class="n">new_head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">old_head</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_head</span><span class="p">,</span><span class="w"> </span><span class="n">old_head</span><span class="p">,</span><span class="w"> </span><span class="n">new_head</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">old_head</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">old_head</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">free_node</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">old_head</span><span class="p">;</span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">old_head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">free_head</span><span class="p">;</span>
<span class="w">            </span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_head</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_head</span><span class="p">,</span><span class="w"> </span><span class="n">old_head</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">old_head</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">enqueue</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">node_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocate_node</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node_idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="n">nodes</span><span class="p">[</span><span class="n">node_idx</span><span class="p">].</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="n">nodes</span><span class="p">[</span><span class="n">node_idx</span><span class="p">].</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">old_tail</span><span class="p">;</span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">old_tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">old_tail</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// 队列为空，CAS更新head和tail</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">node_idx</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_idx</span><span class="p">;</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="n">old_tail</span><span class="p">].</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">node_idx</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 更新tail指针</span>
<span class="w">        </span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tail</span><span class="p">,</span><span class="w"> </span><span class="n">old_tail</span><span class="p">,</span><span class="w"> </span><span class="n">node_idx</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">dequeue</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">old_head</span><span class="p">,</span><span class="w"> </span><span class="n">new_head</span><span class="p">;</span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">old_head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">old_head</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">  </span><span class="c1">// 队列为空</span>

<span class="w">            </span><span class="n">new_head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">old_head</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
<span class="w">            </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">old_head</span><span class="p">].</span><span class="n">data</span><span class="p">;</span>

<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">old_head</span><span class="p">,</span><span class="w"> </span><span class="n">new_head</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">old_head</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 如果队列变空，更新tail</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_head</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tail</span><span class="p">,</span><span class="w"> </span><span class="n">old_head</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">free_node</span><span class="p">(</span><span class="n">old_head</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="652">6.5.2 原子操作与内存序</h3>
<p>CUDA提供了丰富的原子操作和内存序保证：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 内存栅栏确保正确的内存序</span>
<span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">memory_ordering_example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="kt">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flag</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 生产者</span>
<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_value</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// 确保data写入对其他线程可见</span>
<span class="w">        </span><span class="nf">__threadfence_block</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// 设置标志</span>
<span class="w">        </span><span class="n">atomicExch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 消费者</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 等待标志</span>

<span class="w">        </span><span class="c1">// 确保读取最新的data值</span>
<span class="w">        </span><span class="nf">__threadfence_block</span><span class="p">();</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">        </span><span class="n">process</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 使用原子操作实现自旋锁</span>
<span class="n">class</span><span class="w"> </span><span class="n">SpinLock</span><span class="w"> </span><span class="p">{</span>
<span class="n">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>

<span class="n">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">acquire</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 退避策略减少竞争</span>
<span class="w">            </span><span class="n">__nanosleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nf">__threadfence</span><span class="p">();</span><span class="w">  </span><span class="c1">// 获取锁后的内存栅栏</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">release</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nf">__threadfence</span><span class="p">();</span><span class="w">  </span><span class="c1">// 释放锁前的内存栅栏</span>
<span class="w">        </span><span class="n">atomicExch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="653-aba">6.5.3 ABA问题解决方案</h3>
<p>ABA问题是无锁编程的经典问题，需要使用版本号或标记指针解决：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 使用版本号解决ABA问题</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">VersionedPointer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w">     </span><span class="c1">// 16位索引</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">version</span><span class="p">;</span><span class="w">   </span><span class="c1">// 16位版本号</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="nf">VersionedPointer</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">index</span><span class="p">(</span><span class="mi">-1</span><span class="p">),</span><span class="w"> </span><span class="n">version</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="nf">VersionedPointer</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ver</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">index</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span><span class="w"> </span><span class="n">version</span><span class="p">(</span><span class="n">ver</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pack</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">)(</span><span class="n">version</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFF</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">VersionedPointer</span><span class="w"> </span><span class="n">unpack</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">packed</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">VersionedPointer</span><span class="p">(</span>
<span class="w">            </span><span class="n">packed</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFF</span><span class="p">,</span>
<span class="w">            </span><span class="n">packed</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">class</span><span class="w"> </span><span class="n">ABAFreeStack</span><span class="w"> </span><span class="p">{</span>
<span class="n">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">top_packed</span><span class="p">;</span><span class="w">  </span><span class="c1">// 打包的顶部指针（索引+版本）</span>

<span class="n">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">push</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">node_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocate_node</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node_idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="n">nodes</span><span class="p">[</span><span class="n">node_idx</span><span class="p">].</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>

<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">old_packed</span><span class="p">,</span><span class="w"> </span><span class="n">new_packed</span><span class="p">;</span>
<span class="w">        </span><span class="n">VersionedPointer</span><span class="w"> </span><span class="n">old_top</span><span class="p">,</span><span class="w"> </span><span class="n">new_top</span><span class="p">;</span>

<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">old_packed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">top_packed</span><span class="p">;</span>
<span class="w">            </span><span class="n">old_top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VersionedPointer</span><span class="o">::</span><span class="n">unpack</span><span class="p">(</span><span class="n">old_packed</span><span class="p">);</span>

<span class="w">            </span><span class="n">nodes</span><span class="p">[</span><span class="n">node_idx</span><span class="p">].</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_top</span><span class="p">.</span><span class="n">index</span><span class="p">;</span>

<span class="w">            </span><span class="n">new_top</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_idx</span><span class="p">;</span>
<span class="w">            </span><span class="n">new_top</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_top</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 增加版本号</span>
<span class="w">            </span><span class="n">new_packed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_top</span><span class="p">.</span><span class="n">pack</span><span class="p">();</span>

<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">top_packed</span><span class="p">,</span><span class="w"> </span><span class="n">old_packed</span><span class="p">,</span><span class="w"> </span><span class="n">new_packed</span><span class="p">)</span><span class="w"> </span>
<span class="w">                 </span><span class="o">!=</span><span class="w"> </span><span class="n">old_packed</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">old_packed</span><span class="p">,</span><span class="w"> </span><span class="n">new_packed</span><span class="p">;</span>
<span class="w">        </span><span class="n">VersionedPointer</span><span class="w"> </span><span class="n">old_top</span><span class="p">,</span><span class="w"> </span><span class="n">new_top</span><span class="p">;</span>

<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">old_packed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">top_packed</span><span class="p">;</span>
<span class="w">            </span><span class="n">old_top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VersionedPointer</span><span class="o">::</span><span class="n">unpack</span><span class="p">(</span><span class="n">old_packed</span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">old_top</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">  </span><span class="c1">// 栈空</span>

<span class="w">            </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">old_top</span><span class="p">.</span><span class="n">index</span><span class="p">].</span><span class="n">data</span><span class="p">;</span>

<span class="w">            </span><span class="n">new_top</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">old_top</span><span class="p">.</span><span class="n">index</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
<span class="w">            </span><span class="n">new_top</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_top</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 增加版本号</span>
<span class="w">            </span><span class="n">new_packed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_top</span><span class="p">.</span><span class="n">pack</span><span class="p">();</span>

<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">top_packed</span><span class="p">,</span><span class="w"> </span><span class="n">old_packed</span><span class="p">,</span><span class="w"> </span><span class="n">new_packed</span><span class="p">)</span><span class="w"> </span>
<span class="w">                 </span><span class="o">!=</span><span class="w"> </span><span class="n">old_packed</span><span class="p">);</span>

<span class="w">        </span><span class="n">free_node</span><span class="p">(</span><span class="n">old_top</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="654">6.5.4 性能测试与对比</h3>
<p>实际应用中的性能测试框架：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 性能测试内核</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">DataStructure</span><span class="o">&gt;</span>
<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">performance_test</span><span class="p">(</span>
<span class="w">    </span><span class="n">DataStructure</span><span class="o">*</span><span class="w"> </span><span class="n">ds</span><span class="p">,</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">operations</span><span class="p">,</span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">timings</span><span class="p">,</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num_ops</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tid</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_ops</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock64</span><span class="p">();</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">operations</span><span class="p">[</span><span class="n">tid</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 写操作</span>
<span class="w">        </span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 读操作</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock64</span><span class="p">();</span>
<span class="w">    </span><span class="n">timings</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 对比测试：无锁 vs 有锁</span>
<span class="kt">void</span><span class="w"> </span><span class="n">benchmark</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NUM_OPS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000000</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">THREADS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BLOCKS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">NUM_OPS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">THREADS</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">THREADS</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 测试无锁队列</span>
<span class="w">    </span><span class="n">LockFreeQueue</span><span class="o">*</span><span class="w"> </span><span class="n">lf_queue</span><span class="p">;</span>
<span class="w">    </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lf_queue</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">LockFreeQueue</span><span class="p">));</span>

<span class="w">    </span><span class="n">performance_test</span><span class="o">&lt;&lt;&lt;</span><span class="n">BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">THREADS</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span>
<span class="w">        </span><span class="n">lf_queue</span><span class="p">,</span><span class="w"> </span><span class="n">operations</span><span class="p">,</span><span class="w"> </span><span class="n">timings_lockfree</span><span class="p">,</span><span class="w"> </span><span class="n">NUM_OPS</span>
<span class="w">    </span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 测试有锁队列</span>
<span class="w">    </span><span class="n">LockedQueue</span><span class="o">*</span><span class="w"> </span><span class="n">locked_queue</span><span class="p">;</span>
<span class="w">    </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">locked_queue</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">LockedQueue</span><span class="p">));</span>

<span class="w">    </span><span class="n">performance_test</span><span class="o">&lt;&lt;&lt;</span><span class="n">BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">THREADS</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span>
<span class="w">        </span><span class="n">locked_queue</span><span class="p">,</span><span class="w"> </span><span class="n">operations</span><span class="p">,</span><span class="w"> </span><span class="n">timings_locked</span><span class="p">,</span><span class="w"> </span><span class="n">NUM_OPS</span>
<span class="w">    </span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 分析结果</span>
<span class="w">    </span><span class="n">analyze_performance</span><span class="p">(</span><span class="n">timings_lockfree</span><span class="p">,</span><span class="w"> </span><span class="n">timings_locked</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="_1">本章小结</h2>
<p>本章深入探讨了CUDA编程中的warp级编程技术和协作组机制，这些是实现高性能GPU程序的关键技术。我们学习了：</p>
<h3 id="_2">核心概念回顾</h3>
<ol>
<li>
<p><strong>Warp内在函数</strong>
   - Shuffle指令族实现寄存器级数据交换，延迟仅1个时钟周期
   - Vote指令用于warp内条件检查和分支优化
   - Match指令支持动态分组协作
   - 关键优势：避免共享内存访问，减少同步开销</p>
</li>
<li>
<p><strong>协作组编程模型</strong>
   - 提供从单线程到整个网格的灵活线程组织抽象
   - 支持动态分区和重组，适应不规则并行模式
   - 网格级同步实现跨线程块协作
   - 多GPU协作组扩展到分布式计算</p>
</li>
<li>
<p><strong>Warp级算法优化</strong>
   - 归约算法：O(log N)复杂度，无需共享内存
   - 扫描算法：Kogge-Stone并行前缀和
   - 分段操作：处理变长和不规则数据
   - 混合精度：FP16计算 + FP32累加</p>
</li>
<li>
<p><strong>独立线程调度（ITS）</strong>
   - Volta架构引入的重大改进
   - 每线程独立PC和调用栈
   - 需要显式同步保证warp收敛
   - 提供更好的分支效率和硬件利用率</p>
</li>
<li>
<p><strong>无锁数据结构</strong>
   - 原子操作实现线程安全
   - 版本号解决ABA问题
   - 内存栅栏保证正确的内存序
   - 性能优势：避免锁竞争，提高并发度</p>
</li>
</ol>
<h3 id="_3">关键公式与性能指标</h3>
<p><strong>Warp级归约复杂度</strong>：</p>
<ul>
<li>时间复杂度：O(log₂ 32) = O(5)</li>
<li>空间复杂度：O(1)（仅使用寄存器）</li>
</ul>
<p><strong>Shuffle指令吞吐量</strong>：</p>
<ul>
<li>延迟：1个时钟周期</li>
<li>吞吐量：每SM每周期32个shuffle操作</li>
</ul>
<p><strong>协作组同步开销</strong>：</p>
<ul>
<li>线程块同步：~10个时钟周期</li>
<li>网格级同步：~100个时钟周期</li>
<li>Warp同步：1-2个时钟周期</li>
</ul>
<p><strong>无锁vs有锁性能对比</strong>（典型场景）：</p>
<ul>
<li>低竞争：无锁快2-3倍</li>
<li>高竞争：无锁快5-10倍</li>
<li>内存开销：无锁需要额外版本号存储</li>
</ul>
<h3 id="_4">实践要点</h3>
<ol>
<li><strong>优先使用warp原语</strong>：比共享内存更快</li>
<li><strong>显式同步</strong>：ITS架构需要明确的同步点</li>
<li><strong>避免分支分歧</strong>：统一的控制流仍是最优选择</li>
<li><strong>选择合适的数据结构</strong>：根据竞争程度选择有锁/无锁实现</li>
<li><strong>测试验证</strong>：无锁算法需要充分的正确性测试</li>
</ol>
<h2 id="_5">练习题</h2>
<h3 id="_6">基础题</h3>
<p><strong>练习 6.1：Warp级求和</strong>
实现一个使用shuffle指令的warp级浮点数组求和函数，要求支持任意长度（不仅仅是32的倍数）。</p>
<p><em>提示：考虑如何处理不完整的warp和数组边界条件。</em></p>
<details>
<summary>参考答案</summary>
<p>需要考虑三个关键点：</p>
<ol>
<li>使用shuffle_down进行蝶形归约</li>
<li>处理数组长度不是32倍数的情况</li>
<li>多个warp的结果需要通过共享内存或原子操作合并</li>
</ol>
<p>主要步骤：</p>
<ul>
<li>每个线程加载一个或多个元素</li>
<li>warp内使用shuffle归约</li>
<li>warp 0的线程0收集最终结果</li>
<li>考虑使用Kahan求和减少浮点误差</li>
</ul>
</details>
<p><strong>练习 6.2：协作组分区</strong>
使用协作组API实现一个函数，将线程块动态分成4个组，每组独立计算其负责数据的最大值。</p>
<p><em>提示：使用tiled_partition创建固定大小的分区。</em></p>
<details>
<summary>参考答案</summary>
<p>关键实现要点：</p>
<ol>
<li>使用<code>tiled_partition&lt;8&gt;</code>创建8线程的tiles（假设32线程的warp）</li>
<li>每个tile独立进行最大值归约</li>
<li>使用<code>tile.shfl</code>进行tile内通信</li>
<li>最后合并4个组的结果</li>
</ol>
<p>注意事项：</p>
<ul>
<li>确保线程块大小是分区大小的倍数</li>
<li>正确处理tile边界</li>
<li>使用tile.sync()进行同步</li>
</ul>
</details>
<p><strong>练习 6.3：Vote指令优化</strong>
给定一个条件判断函数，使用vote指令优化分支执行，减少warp分歧。</p>
<p><em>提示：使用__ballot_sync收集所有线程的条件结果。</em></p>
<details>
<summary>参考答案</summary>
<p>优化策略：</p>
<ol>
<li>使用<code>__ballot_sync</code>获取所有线程的条件掩码</li>
<li>根据掩码判断是否所有线程都走同一分支</li>
<li>如果统一，则避免分支；如果分歧，则正常执行</li>
<li>使用<code>__popc</code>计算满足条件的线程数</li>
</ol>
<p>性能提升：</p>
<ul>
<li>完全统一的分支：避免分歧开销</li>
<li>部分分歧：可以提前知道活跃线程数</li>
</ul>
</details>
<p><strong>练习 6.4：简单无锁栈</strong>
实现一个基础的无锁栈，支持push和pop操作，不需要处理ABA问题。</p>
<p><em>提示：使用atomicCAS操作栈顶指针。</em></p>
<details>
<summary>参考答案</summary>
<p>实现要点：</p>
<ol>
<li>使用单个整数作为栈顶索引</li>
<li>push：CAS更新栈顶，新节点指向旧栈顶</li>
<li>pop：CAS更新栈顶为next节点</li>
<li>使用预分配的节点池避免动态内存分配</li>
</ol>
<p>注意：</p>
<ul>
<li>这个简单版本存在ABA问题</li>
<li>适用于生产者-消费者数量固定的场景</li>
<li>需要处理空栈和满栈情况</li>
</ul>
</details>
<h3 id="_7">挑战题</h3>
<p><strong>练习 6.5：高效前缀和</strong>
实现一个处理大数组（百万级元素）的并行前缀和算法，要求：</p>
<ul>
<li>使用warp级原语优化</li>
<li>支持分段扫描（给定段边界数组）</li>
<li>达到接近内存带宽的性能</li>
</ul>
<p><em>提示：结合warp级扫描、共享内存和多级归约。</em></p>
<details>
<summary>参考答案</summary>
<p>三级扫描架构：</p>
<ol>
<li><strong>Warp级</strong>：每个warp处理32个元素，使用shuffle</li>
<li><strong>Block级</strong>：warp结果存入共享内存，进行block级扫描</li>
<li><strong>Grid级</strong>：block结果存入全局内存，递归或单独kernel处理</li>
</ol>
<p>分段扫描处理：</p>
<ul>
<li>段边界作为扫描重置点</li>
<li>使用标志数组标记段起始</li>
<li>warp内使用条件shuffle处理段边界</li>
</ul>
<p>优化技巧：</p>
<ul>
<li>向量化加载（float4）提高带宽利用</li>
<li>双缓冲隐藏内存延迟</li>
<li>使用__ldg进行只读缓存</li>
</ul>
</details>
<p><strong>练习 6.6：动态任务调度器</strong>
设计一个基于协作组的动态任务调度器，支持：</p>
<ul>
<li>任务动态生成和消费</li>
<li>负载均衡</li>
<li>优先级队列</li>
</ul>
<p><em>提示：结合无锁队列和协作组动态分区。</em></p>
<details>
<summary>参考答案</summary>
<p>架构设计：</p>
<ol>
<li><strong>任务池</strong>：多个优先级的无锁队列</li>
<li><strong>工作窃取</strong>：空闲线程组从其他组窃取任务</li>
<li><strong>动态分组</strong>：根据任务类型动态重组协作组</li>
</ol>
<p>关键技术：</p>
<ul>
<li>使用match指令识别相同优先级的任务</li>
<li>labeled_partition创建任务执行组</li>
<li>原子操作管理任务计数器</li>
<li>指数退避减少竞争</li>
</ul>
<p>性能考虑：</p>
<ul>
<li>批量获取任务减少原子操作</li>
<li>局部任务缓存减少全局访问</li>
<li>自适应分组大小</li>
</ul>
</details>
<p><strong>练习 6.7：无锁哈希表</strong>
实现一个GPU上的高性能无锁哈希表，要求：</p>
<ul>
<li>支持并发插入、查找和删除</li>
<li>处理哈希冲突</li>
<li>解决ABA问题</li>
</ul>
<p><em>提示：使用开放寻址法和版本号技术。</em></p>
<details>
<summary>参考答案</summary>
<p>设计要点：</p>
<ol>
<li><strong>开放寻址</strong>：线性探测或二次探测</li>
<li><strong>槽位状态</strong>：空闲、占用、已删除（墓碑）</li>
<li><strong>版本号</strong>：每个槽位包含版本号防止ABA</li>
</ol>
<p>并发控制：</p>
<ul>
<li>CAS操作更新槽位</li>
<li>版本号与键值打包成64/128位</li>
<li>删除使用墓碑标记，延迟回收</li>
</ul>
<p>优化策略：</p>
<ul>
<li>SIMD并行探测多个槽位</li>
<li>使用__match_any_sync找相同键的线程</li>
<li>局部重哈希减少冲突</li>
<li>分段锁降低竞争（混合方案）</li>
</ul>
</details>
<p><strong>练习 6.8：自动驾驶场景 - 点云并行聚类</strong>
实现一个基于DBSCAN的并行点云聚类算法，用于自动驾驶中的障碍物检测：</p>
<ul>
<li>输入：激光雷达点云（10万点）</li>
<li>使用warp级原语加速邻域搜索</li>
<li>支持动态簇合并</li>
</ul>
<p><em>提示：结合空间哈希、warp级归约和无锁并查集。</em></p>
<details>
<summary>参考答案</summary>
<p>算法流程：</p>
<ol>
<li><strong>空间划分</strong>：构建3D网格哈希</li>
<li><strong>邻域搜索</strong>：warp协作搜索邻近体素</li>
<li><strong>核心点识别</strong>：使用vote指令快速判断</li>
<li><strong>簇扩展</strong>：无锁并查集合并连通分量</li>
</ol>
<p>关键优化：</p>
<ul>
<li>Warp级并行处理一个体素的所有点</li>
<li>Shuffle交换邻域信息</li>
<li>Match指令组织相同簇的线程</li>
<li>原子操作更新簇标签</li>
</ul>
<p>性能指标：</p>
<ul>
<li>目标：10ms处理10万点</li>
<li>内存访问合并提升带宽利用</li>
<li>减少原子操作竞争</li>
<li>充分利用纹理缓存加速邻域查询</li>
</ul>
</details>
<h2 id="_8">常见陷阱与错误</h2>
<h3 id="1-shuffle">1. Shuffle指令的同步问题</h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：未使用_sync版本</span>
<span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl</span><span class="p">(</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">srcLane</span><span class="p">);</span><span class="w">  </span><span class="c1">// 已废弃，可能导致未定义行为</span>

<span class="c1">// 正确：使用_sync版本并指定mask</span>
<span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_sync</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">srcLane</span><span class="p">);</span>
</code></pre></div>

<p><strong>陷阱说明</strong>：从CUDA 9.0开始，非_sync版本已废弃。必须使用_sync版本并明确指定参与线程的mask。</p>
<h3 id="2">2. 协作组的生命周期管理</h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：在条件分支中创建协作组</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">());</span>
<span class="w">    </span><span class="c1">// 只有部分线程创建了tile，导致死锁</span>
<span class="p">}</span>

<span class="c1">// 正确：所有线程都创建协作组，然后条件使用</span>
<span class="k">auto</span><span class="w"> </span><span class="n">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">());</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 使用tile</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>陷阱说明</strong>：协作组的创建必须由所有参与线程执行，否则会导致死锁或未定义行为。</p>
<h3 id="3-its">3. ITS架构下的隐式假设</h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：假设warp自动收敛</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">compute_a</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">compute_b</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// 危险：假设所有线程都到达这里</span>
<span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_sync</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// 正确：显式同步</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__activemask</span><span class="p">();</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">compute_a</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">compute_b</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">__syncwarp</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span><span class="w">  </span><span class="c1">// 确保收敛</span>
<span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_sync</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>

<p><strong>陷阱说明</strong>：Volta+架构不保证分支后的自动收敛，必须显式同步。</p>
<h3 id="4-aba">4. 原子操作的ABA问题</h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// 危险：简单CAS可能遭遇ABA问题</span>
<span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
<span class="n">Node</span><span class="o">*</span><span class="w"> </span><span class="n">new_top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">top</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="c1">// 如果这期间top被pop又push回来...</span>
<span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">new_top</span><span class="p">);</span><span class="w">  </span><span class="c1">// 错误地成功</span>

<span class="c1">// 解决：使用版本号</span>
<span class="n">VersionedPtr</span><span class="w"> </span><span class="n">old_top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
<span class="n">VersionedPtr</span><span class="w"> </span><span class="nf">new_top</span><span class="p">(</span><span class="n">old_top</span><span class="p">.</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">old_top</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">atomicCAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">old_top</span><span class="p">.</span><span class="n">packed</span><span class="p">,</span><span class="w"> </span><span class="n">new_top</span><span class="p">.</span><span class="n">packed</span><span class="p">);</span>
</code></pre></div>

<p><strong>陷阱说明</strong>：无锁数据结构必须考虑ABA问题，使用版本号或hazard pointer技术。</p>
<h3 id="5-matchmask">5. Match指令的mask误用</h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：使用全mask但不是所有线程都活跃</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">peers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__match_any_sync</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>

<span class="c1">// 正确：使用实际活跃的线程mask</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__activemask</span><span class="p">();</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">peers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__match_any_sync</span><span class="p">(</span><span class="n">active</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
</code></pre></div>

<p><strong>陷阱说明</strong>：match指令的mask必须准确反映活跃线程，否则会hang。</p>
<h3 id="6">6. 网格级同步的启动要求</h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：普通内核启动</span>
<span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span>

<span class="c1">// 正确：协作内核启动</span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">args</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="o">&amp;</span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg2</span><span class="p">};</span>
<span class="n">cudaLaunchCooperativeKernel</span><span class="p">(</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span>
</code></pre></div>

<p><strong>陷阱说明</strong>：网格级同步需要特殊的协作内核启动API。</p>
<h3 id="7-warp">7. Warp级归约的边界处理</h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// 错误：未处理非32倍数的情况</span>
<span class="kt">float</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">warpReduce</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">tid</span><span class="p">]);</span><span class="w">  </span><span class="c1">// tid &gt;= N时访问越界</span>

<span class="c1">// 正确：添加边界检查</span>
<span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">warpReduce</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</code></pre></div>

<p><strong>陷阱说明</strong>：warp级操作必须考虑数组边界和不完整warp。</p>
<h3 id="8">8. 内存栅栏的过度使用</h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// 低效：不必要的全局栅栏</span>
<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="nf">__threadfence</span><span class="p">();</span><span class="w">  </span><span class="c1">// 过度同步</span>

<span class="c1">// 优化：根据需要选择合适的栅栏</span>
<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared_counter</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="nf">__threadfence_block</span><span class="p">();</span><span class="w">  </span><span class="c1">// 仅块内同步</span>
</code></pre></div>

<p><strong>陷阱说明</strong>：选择合适粒度的内存栅栏，避免不必要的性能损失。</p>
<h3 id="_9">调试技巧</h3>
<ol>
<li><strong>使用assert检查mask</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">assert</span><span class="p">(</span><span class="n">__popc</span><span class="p">(</span><span class="n">__activemask</span><span class="p">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">expected_threads</span><span class="p">);</span>
</code></pre></div>

<ol start="2">
<li><strong>打印调试信息</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Active mask: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">__activemask</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div>

<ol start="3">
<li>
<p><strong>使用Nsight Compute分析</strong>：
- 检查warp占用率
- 分析分支效率
- 查看原子操作竞争</p>
</li>
<li>
<p><strong>渐进式测试</strong>：
- 先测试单warp
- 再测试单block
- 最后测试完整grid</p>
</li>
</ol>
<h2 id="_10">最佳实践检查清单</h2>
<h3 id="_11">设计阶段</h3>
<ul>
<li>[ ] <strong>选择合适的并行粒度</strong></li>
<li>Warp级操作适合细粒度并行</li>
<li>协作组适合灵活的线程组织</li>
<li>
<p>评估分支分歧的影响</p>
</li>
<li>
<p>[ ] <strong>数据结构选择</strong></p>
</li>
<li>高竞争场景优先考虑无锁结构</li>
<li>低竞争场景可以使用简单的原子操作</li>
<li>
<p>考虑ABA问题和内存序要求</p>
</li>
<li>
<p>[ ] <strong>算法设计</strong></p>
</li>
<li>优先使用warp级原语（shuffle、vote）</li>
<li>设计时考虑32线程的warp大小</li>
<li>利用协作组实现灵活的并行模式</li>
</ul>
<h3 id="_12">实现阶段</h3>
<ul>
<li>[ ] <strong>Warp操作正确性</strong></li>
<li>所有warp原语使用_sync版本</li>
<li>正确设置参与线程的mask</li>
<li>
<p>处理不完整warp的边界情况</p>
</li>
<li>
<p>[ ] <strong>协作组使用</strong></p>
</li>
<li>所有线程参与协作组创建</li>
<li>使用合适的同步粒度</li>
<li>
<p>正确处理动态分区</p>
</li>
<li>
<p>[ ] <strong>ITS兼容性</strong></p>
</li>
<li>分支后显式同步</li>
<li>使用__activemask()获取活跃线程</li>
<li>
<p>避免隐式收敛假设</p>
</li>
<li>
<p>[ ] <strong>原子操作优化</strong></p>
</li>
<li>使用合适的内存栅栏</li>
<li>考虑使用warp级聚合减少竞争</li>
<li>实现退避策略减少冲突</li>
</ul>
<h3 id="_13">优化阶段</h3>
<ul>
<li>[ ] <strong>性能分析</strong></li>
<li>测量warp执行效率</li>
<li>分析分支分歧程度</li>
<li>
<p>检查原子操作竞争</p>
</li>
<li>
<p>[ ] <strong>内存访问优化</strong></p>
</li>
<li>Shuffle操作替代共享内存</li>
<li>合并全局内存访问</li>
<li>
<p>使用适当的缓存策略</p>
</li>
<li>
<p>[ ] <strong>负载均衡</strong></p>
</li>
<li>动态任务分配</li>
<li>工作窃取策略</li>
<li>自适应分组大小</li>
</ul>
<h3 id="_14">测试阶段</h3>
<ul>
<li>[ ] <strong>功能测试</strong></li>
<li>单warp测试</li>
<li>多warp协作测试</li>
<li>
<p>边界条件测试</p>
</li>
<li>
<p>[ ] <strong>并发测试</strong></p>
</li>
<li>高竞争场景测试</li>
<li>ABA问题验证</li>
<li>
<p>死锁检测</p>
</li>
<li>
<p>[ ] <strong>性能测试</strong></p>
</li>
<li>不同数据规模</li>
<li>不同GPU架构</li>
<li>与其他实现对比</li>
</ul>
<h3 id="_15">部署阶段</h3>
<ul>
<li>[ ] <strong>架构兼容性</strong></li>
<li>检查Compute Capability要求</li>
<li>提供Pre-Volta兼容版本</li>
<li>
<p>运行时架构检测</p>
</li>
<li>
<p>[ ] <strong>错误处理</strong></p>
</li>
<li>原子操作失败重试</li>
<li>资源耗尽处理</li>
<li>
<p>超时机制</p>
</li>
<li>
<p>[ ] <strong>监控指标</strong></p>
</li>
<li>Warp效率监控</li>
<li>原子操作冲突率</li>
<li>内存带宽利用率</li>
</ul>
<h3 id="_16">代码审查要点</h3>
<ol>
<li><strong>同步正确性</strong>：每个warp操作都有正确的同步</li>
<li><strong>Mask准确性</strong>：__activemask()使用正确</li>
<li><strong>边界处理</strong>：处理了所有边界情况</li>
<li><strong>资源管理</strong>：无锁结构的内存管理正确</li>
<li><strong>性能瓶颈</strong>：识别并优化了关键路径</li>
</ol>
<h3 id="_17">文档要求</h3>
<ul>
<li>[ ] 记录算法的并行策略</li>
<li>[ ] 说明架构要求和限制</li>
<li>[ ] 提供性能基准测试结果</li>
<li>[ ] 包含使用示例和最佳实践</li>
<li>[ ] 列出已知问题和解决方案</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter5.html" class="nav-link prev">← 第5章：寄存器优化与常量内存</a><a href="chapter7.html" class="nav-link next">第7章：原子操作与同步原语 →</a></nav>
        </main>
    </div>
</body>
</html>